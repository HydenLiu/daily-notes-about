## HTML5 新增

* （1）新增语义化标签：nav、header、footer、aside、section、article
* （2）音频、视频标签：audio、video
* （3）数据存储：localStorage、sessionStorage
* （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）
* （5）input标签新增属性：placeholder、autocomplete、autofocus、required
* （6）history API：go、forward、back、pushstate

## CSS3新增

* 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）
* 圆角 （border-radius:8px）
* 多列布局 （multi-column layout）
* 阴影和反射 （Shadoweflect）
* 文字特效 （text-shadow）
* 文字渲染 （Text-decoration）
* 线性渐变 （gradient）
* 旋转 （transform）
* 增加了旋转,缩放,定位,倾斜,动画,多背景

## margin 重合解决办法

（1）兄弟之间重叠

- 底部元素变为行内盒子：`display: inline-block`
- 底部元素设置浮动：`float`
- 底部元素的position的值为`absolute/fixed`

（2）父子之间重叠

- 父元素加入：`overflow: hidden`
- 父元素添加透明边框：`border:1px solid transparent`
- 子元素变为行内盒子：`display: inline-block`
- 子元素加入浮动属性或定位

## new 操作符执行过程

* （1）首先创建了一个新的空对象
* （2）设置原型，将对象的原型设置为函数的 prototype 对象。
* （3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
* （4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

## 将 驼峰式 命名的属性改为 下划线 式

```js
let obj = {
  myPlay: 12
}

let newObj = {}
for (let key in obj) {
  newObj[key.replace(/([A-Z])/g, "_$1").toLowerCase()] = obj[key]
};

console.log(newObj)
```

## vue

``` vue
// project/inject 依赖注入，不是响应式的
// keep-alive 用于对组件的缓存，切换路由时保存状态再内存中，防止重复渲染dom
```



## React

``` js
// 阻止事件冒泡：event.preventDfault()

// 生命周期
• 挂载过程：
	constructor
    getDerivedStateFromProps
 	render
 	componentDidMount
• 更新过程：
 	getDerivedStateFromProps
 	shouldComponentUpdate
 	render
 	getSnapshotBeforeUpdate
 	componentDidUpdate
• 卸载过程：
 	componentWillUnmount
```

- `componentDidCatch` and `getDerivedStateFromError`：目前**还没有**这些方法的 Hook 等价写法，但很快会加上。

| **class 组件**           | **Hooks 组件**            |
| ------------------------ | ------------------------- |
| constructor              | useState                  |
| getDerivedStateFromProps | useState 里面 update 函数 |
| shouldComponentUpdate    | useMemo                   |
| render                   | 函数本身                  |
| componentDidMount        | useEffect                 |
| componentDidUpdate       | useEffect                 |
| componentWillUnmount     | useEffect 里面返回的函数  |
| componentDidCatch        | 无                        |
| getDerivedStateFromError | 无                        |

## webpack

###  如何⽤**webpack**来优化前端性能？ 

⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 

- **压缩代码**：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css 
- **利⽤ ** **CDN** **加速**: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 

- **Tree Shaking**: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现
- **Code Splitting:** 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 

- **提取公共第三⽅库**: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码 

###  如何提⾼**webpack**的构建速度？ 

1. 多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码 
2. 通过 externals 配置来提取常⽤库 

1. 利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 
2. 使⽤ Happypack 实现多线程加速编译 

1. 使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度 
2. 使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码 



## 问题

1、nextTick

2、前端性能优化

3、webpack打包优化

4、ts中type和interface的区别:  interface: 同名合并;type 支持计算属性，生成映射类型, 内部使用了 for .. in

5、项目中遇到的问题

6、react和小程序的生命周期